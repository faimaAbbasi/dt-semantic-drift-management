'use strict'
const should = require('should')
const ch = require('../index.js')
const _ = require('lodash')

function evenElts (xs) { return _.filter(xs, x => x % 2 === 0) }
function multipleOf(y) { return (x => x % y === 0) }

describe ('checker initialisation', function () {
  it ('works with initial values', function (done) {
    const rules = {r1: new ch.Rule(ch.all(x => x), x => x % 2 === 0)}
    const helpers = {h1: x => x + 1}
    const c = new ch.Checker(helpers, rules)
    c.helpers.should.have.property('h1')
    c.rules.should.have.property('r1')
    done()
  })
})

describe ('1 selection forall-check on arrays', function () {
  it ('always pass if no element matches the selection', function (done) {
    const cs = new ch.Checker()
    cs.rules['no match'] = ch.Rule.define(
      ch.all(x => []),
      y => false
      )
    cs.run([1,2,3,4]).succeed.should.be.true()
    cs.run(undefined).succeed.should.be.true()
    done()
  })
  it ('always pass if the predicate is always true', function (done) {
    const cs = new ch.Checker()
    cs.rules['always pass find a match'] = ch.Rule.define(
      ch.all(_.identity),
      y => true
      )
    cs.run([1,2,3,4]).succeed.should.be.true()
    cs.run([]).succeed.should.be.true()
    cs.run(['abc', 'def', 'ghi']).succeed.should.be.true()
    done()
  })
  it ('pass if matching elements matches the predicate', function (done) {
    const cs = new ch.Checker()
    cs.rules['evenElementsAreMultipleOf3'] = ch.Rule.define(
      ch.all(evenElts),
      multipleOf(3)
      )
    cs.run([1,6,12]).succeed.should.be.true()
    done()
  })
  it ('returns the list of failing rules and elements', function (done) {
    const cs = new ch.Checker()
    cs.rules.testRule = ch.Rule.define(
      ch.all(evenElts),
      multipleOf(3)
      )
    const test = cs.run([4, 8, 12])
    test.succeed.should.be.false()
    _.values(test.errors).should.have.length(1)
    should.exist(test.errors.testRule)
    test.errors.testRule.should.have.length(2)
    test.errors.testRule.should.containDeep([[4],[8]])
    done()
  })
})

describe ('1 selection exists-check on arrays', function () {
  it ('pass if one matching elements matches the exisential predicate', function (done) {
    const cs = new ch.Checker()
    cs.rules.oneElementIsMultipleOf3 = ch.Rule.define(
      ch.any(evenElts),
      multipleOf(3)
      )
    cs.run([4,6]).succeed.should.be.true()
    done()
  })
})

describe ('1 selection raw-check on arrays', function () {
  it ('checks global rules', function(done) {
    const cs = new ch.Checker()
    cs.rules['4even'] = ch.Rule.define(
      ch.raw(evenElts),
      xs => xs.length === 4
      )
    cs.run([4,5,6,7,8,9,10]).succeed.should.be.true()
    done()
  })
})
describe ('InnerReference', function () {
  it ('map values depending on the context', function(done) {
    const cs = new ch.Checker()
    cs.rules['evenSizeInTheList'] = ch.Rule.define(
      ch.all(x => x.foo),
      ch.any(new ch.ContextualReference(function () {
        return this[0].filter(x => x % 2 === 0)
      })),
      (x,m) => x.length === m
      )
    cs.run({foo: [[2,3,4,6], [3,2]]}).succeed.should.be.true()
    done()
  })
})


describe('Transformation.check', function () {
  it('works on valid transformation', function (done) {
    const cs = new ch.Checker()
    function multipleOf6 (xs) { return _.filter(xs, x => x % 6 === 0) }
  cs.rules.filter6AndIncrement = ch.Rule.define(
    ch.all(x => multipleOf6(x.in)),
    ch.any(x => x.out),
    (s,t) => s+1 == t
    )
    cs.run({in: [2,3,4,6], out: [7]}).succeed.should.be.true()
    done()
  })
  it('returns invalid value', function (done) {
    const cs = new ch.Checker()
    function multipleOf6 (xs) { return _.filter(xs, x => x % 6 === 0) }
  cs.rules.filter6AndIncrement = ch.Rule.define(
    ch.all(x => multipleOf6(x.in)),
    ch.all(x => x.out),
    (s,t) => s+1 == t
    )
    const test = cs.run({in: [2,3,4,6], out: [7,8]})
    test.succeed.should.be.false()
    should.exist(test.errors.filter6AndIncrement)
    test.errors.filter6AndIncrement.should.have.length(1)
    test.errors.filter6AndIncrement.should.containEql([6, 8])
    done()
  })
  it('works with global rules', function (done) {
    const cs = new ch.Checker()
    cs.rules.filterEven = ch.Rule.define(
      ch.raw(x => evenElts(x.in)),
      ch.raw(x => evenElts(x.out)),
      (s,t) => s.length == t.length
      )
    cs.run({in: [2,3,4,6], out: [6,8,10]}).succeed.should.be.true()
    done()
  })
  it('works with existential rules', function (done) {
    const cs = new ch.Checker()
    cs.rules.succ = ch.Rule.define(
      ch.all(x => x.in),
      ch.any(x => x.out),
      (s,t) => s+1 === t
      )
    cs.run({in: [2,3,4,5], out: [3,4,5,6]}).succeed.should.be.true()
    done()
  })
})

describe('composeCheckers', function () {

  it ('combines helpers', function (done) {
    const c1 = new ch.Checker()
        , c2 = new ch.Checker()
    c1.addHelper('first4', x => x.slice(0,4))
    c2.addHelper('last4', x => x.slice(-4))
    const cs = ch.composeCheckers(c1,c2)
    cs.helpers.should.have.property('first4')
    cs.helpers.should.have.property('last4')
    done()
  })

  it ('keeps initial helpers', function (done) {
    const c1 = new ch.Checker()
        , c2 = new ch.Checker()
    c1.addHelper('first4', x => x.slice(0,4))
    c2.addHelper('last4', x => x.slice(-4))
    ch.composeCheckers(c1,c2)
    c1.helpers.should.not.have.property('last4')
    c2.helpers.should.not.have.property('first4')
    done()
  })

  it ('combines rules', function (done) {
    const c1 = new ch.Checker()
        , c2 = new ch.Checker()
    c1.addRule('sizeIs4', ch.raw(x => x), x => x.length == 4)
    c2.addRule('elementsSizeIs4', ch.all(x => x), x => x.length == 4)
    const cs = ch.composeCheckers(c1,c2)
    cs.rules.should.have.property('sizeIs4')
    cs.rules.should.have.property('elementsSizeIs4')
    done()
  })

  it ('keppe original unchanged', function (done) {
    const c1 = new ch.Checker()
        , c2 = new ch.Checker()
    c1.addRule('sizeIs4', ch.raw(x => x), x => x.length == 4)
    c2.addRule('elementsSizeIs4', ch.all(x => x), x => x.length == 4)
    const cs = ch.composeCheckers(c1,c2)
    c1.rules.should.not.have.property('elementsSizeIs4')
    c2.rules.should.not.have.property('sizeIs4')
    done()
  })

})
